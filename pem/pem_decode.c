#include <ssl/ssl.h>
#include <ssl/rand.h>
#include <ssl/base64.h>
#include <ssl/pem.h>
#include <ssl/des.h>
#include <util/parser.h>
#include <libft/2darray.h>
#include <libft/bytes.h>

static const char	*PEM_PROC = "Proc-Type: ";
static const char	*DEK_INFO = "DEK-Info: ";

static char			*__content;
static size_t		__consize;
static t_bool		__encrypted;
static char			__vecthex[16];

// Encrypted PEM format:
//
// -----BEGIN X-----
// Proc-Type: 4,ENCRYPTED
// DEK-Info: CIPHER,PIV
// [ ... BASE64 ENCODING ... ]
// -----END X-----
//
// OpenSSL uses a non-standard ecryption format for PEM encoding.
// PEM initial vector (PIV) is used for both CIPHER salt and
// CIPHER initial vector. Thus, CIPHER key is generated using PIV as a salt.
// Generated key and PIV is then passed to CIPHER.
// Initial vector generated by PBKDF function is ignored.

static int __decrypt(void)
{
	t_des			*des;
	t_ostring		cipher;
	t_ostring		message;
	unsigned char	vect[8];
	unsigned char	key[8];

	ft_hex_to_bytes(vect, __vecthex, 16);

	if (SSL_OK != rand_pbkdf2(key, vect, NULL))
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	des = des_init(key, NULL, vect);
	cipher.content = __content;
	cipher.size = __consize;

	if (SSL_OK != des_cbc_decrypt(des, &cipher, &message))
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	SSL_FREE(__content);
	__content = (char *)message.content;
	__consize = message.size;

	return (SSL_OK);
}

static int __parse_proc(const char *proc)
{
	char	**proc_info;
	char	**proc_type;
	int		check;

	proc_info = ft_strsplit(proc, ' ');

	if (ft_2darray_len_null_terminated((void **)proc_info) < 2)
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	proc_type = ft_strsplit(proc_info[1], ',');

	check = (ft_2darray_len_null_terminated((void **)proc_type) < 2);
	check += ft_strcmp("4", proc_type[0]);
	check += ft_strcmp("ENCRYPTED", proc_type[1]);

	ft_2darray_del_null_terminated((void **)proc_type);
	ft_2darray_del_null_terminated((void **)proc_info);

	if (check != 0)
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	return (SSL_OK);
}

static int __parse_dek(const char *dek)
{
	char	**dek_info;
	char	**dek_cipher;
	int		check;

	dek_info = ft_strsplit(dek, ' ');

	if (ft_2darray_len_null_terminated((void **)dek_info) < 2)
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	dek_cipher = ft_strsplit(dek_info[1], ',');

	check = (ft_2darray_len_null_terminated((void **)dek_cipher) < 2);
	check += ft_strcmp("DES-CBC", dek_cipher[0]);
	check += (ft_strlen(dek_cipher[1]) != 16);
	check += !ft_str_ishex(dek_cipher[1]);

	ft_memcpy(__vecthex, dek_cipher[1], MIN(16, ft_strlen(dek_cipher[1])));
	ft_2darray_del_null_terminated((void **)dek_cipher);
	ft_2darray_del_null_terminated((void **)dek_info);

	if (check != 0)
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	return (SSL_OK);
}

static int	__check_crypt_header(const char *proc, const char *dek)
{
	int	procidx;
	int	dekidx;
	int	proclen;
	int	deklen;

	if ((NULL == proc) || (NULL == dek))
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	procidx = parser_find(__content, __consize, PEM_PROC, ft_strlen(PEM_PROC));
	dekidx = parser_find(__content, __consize, DEK_INFO, ft_strlen(DEK_INFO));
	proclen = ft_strlen(proc);
	deklen = ft_strlen(dek);

	if (procidx > dekidx)
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	if (dekidx + deklen + 1 >= __consize) // include newline character
		return (PEM_ERROR(UNSPECIFIED_ERROR));

	return (SSL_OK);
}

static void	__remove_crypt_header(void)
{
	char	*dek;
	int		dekidx;
	int		idx;

	dekidx = parser_find(__content, __consize, DEK_INFO, ft_strlen(DEK_INFO));
	dek = parser_line(__content, __consize, DEK_INFO, ft_strlen(DEK_INFO));
	idx = dekidx + ft_strlen(dek);

	// remove header by overriding it and adjusting content size,
	// in other words, by shifting content to the left
	ft_memcpy(__content, __content + idx, __consize - idx);
	__consize -= idx;
}

static int	__parse_crypt_header(void)
{
	char	*proc;
	char	*dek;
	int		ret;

	ret = SSL_OK;
	dek = parser_line(__content, __consize, DEK_INFO, ft_strlen(DEK_INFO));
	proc = parser_line(__content, __consize, PEM_PROC, ft_strlen(PEM_PROC));

	if (SSL_OK != __check_crypt_header(proc, dek))
		ret = PEM_ERROR(UNSPECIFIED_ERROR);

	else if (SSL_OK != __parse_proc(proc))
		ret = PEM_ERROR(UNSPECIFIED_ERROR);

	else if (SSL_OK != __parse_dek(dek))
		ret = PEM_ERROR(UNSPECIFIED_ERROR);

	SSL_FREE(proc);
	SSL_FREE(dek);

	return (ret);
}

static int __decode(void)
{
	char	*b64enc;
	int		b64len;
	int		ret;

	ret = SSL_OK;

	if (parser_find(__content, __consize, PEM_PROC, ft_strlen(PEM_PROC)) >= 0)
	{
		__encrypted = SSL_TRUE;

		if (SSL_OK != __parse_crypt_header())
			return (PEM_ERROR(UNSPECIFIED_ERROR));

		__remove_crypt_header();
	}
	parser_del_eolws(__content, __consize, &b64enc, &b64len);
	SSL_FREE(__content);

	if (SSL_OK != base64_decode(b64enc, b64len, &__content, &__consize))
		ret = PEM_ERROR(UNSPECIFIED_ERROR);

	else if (SSL_TRUE == __encrypted)
		ret = __decrypt();

	SSL_FREE(b64enc);

	return (ret);
}

int pem_decode(t_pem *pem, const char *type, t_ostring **content)
{
	if (NULL == pem || NULL == content) {
		return (PEM_ERROR(INVALID_INPUT_ERROR));
	}
	__encrypted = SSL_FALSE;
	*content = NULL;

	if (SSL_OK != pem_decap(pem, type, &__content, &__consize)) {
		return (PEM_ERROR("invalid pem encoding"));
	}
	if (SSL_OK != __decode()) {
		return (PEM_ERROR("invalid pem encoding"));
	}
	SSL_ALLOC(*content, sizeof(t_ostring));

	(*content)->content = __content;
	(*content)->size = __consize;

	return (SSL_OK);
}
