#include <ssl/ssl.h>
#include <ssl/rand.h>
#include <ssl/pem.h>
#include <ssl/base64.h>
#include <ssl/des.h>
#include <util/parser.h>
#include <libft/bytes.h>

static const char	*PEM_PROC = "Proc-Type: 4,ENCRYPTED\n";
static const char	*DEK_INFO = "DEK-Info: DES-CBC,";

static unsigned char __vect[8];

// Encrypted PEM format:
//
// -----BEGIN X-----
// Proc-Type: 4,ENCRYPTED
// DEK-Info: CIPHER,PEMIV
// [ ... BASE64 ENCODING ... ]
// -----END X-----
//
// OpenSSL uses a non-standard ecryption format for PEM encoding.
// PEM initial vector (PEMIV) is used as CIPHER salt and
// CIPHER initial vector. Thus, CIPHER key is generated using PEMIV
// as a salt. Generated key and PEMIV (aka initial vector) are then
// passed to CIPHER. Initial vector generated by PBKDF function
// is ignored.

static int	__des_crypt(t_ostring *content, t_ostring *cipher)
{
	t_des	*des;
	unsigned char	key[8];

	if ((SSL_OK != rand_useed((uint64_t *)__vect, 8))
		|| (SSL_OK != rand_pbkdf2(key, __vect, NULL)))
	{
		return (PEM_ERROR(UNSPECIFIED_ERROR));
	}
	des = des_init(key, NULL, __vect);

	if (SSL_OK != des_cbc_encrypt(des, content, cipher))
	{
		return (PEM_ERROR(UNSPECIFIED_ERROR));
	}
	ft_bzero(key, sizeof(key));

	return (SSL_OK);
}

static void	__concat(
	char *dst, size_t *dstsize, const char *src, size_t srcsize)
{
	ft_memcpy(dst + *dstsize, src, srcsize);
	*dstsize += srcsize;
}

static void	__crypt_header(char **chead, size_t *chsize)
{
	char	*vecthex;

	SSL_ALLOC(*chead, ft_strlen(PEM_PROC) + ft_strlen(DEK_INFO) + 16 + 2);
	vecthex = ft_bytes_to_hex(__vect, sizeof(__vect));

	*chsize = 0;
	__concat(*chead, chsize, PEM_PROC, ft_strlen(PEM_PROC));
	__concat(*chead, chsize, DEK_INFO, ft_strlen(DEK_INFO));
	__concat(*chead, chsize, vecthex, ft_strlen(vecthex));
	__concat(*chead, chsize, "\n\n", 2);

	SSL_FREE(vecthex);
}

static int	__encode(t_ostring *content, char **pemenc, size_t *pemsize)
{
	if (SSL_OK != base64_encode(
		(char *)(content->content), content->size, pemenc, pemsize))
	{
		return (PEM_ERROR(UNSPECIFIED_ERROR));
	}
	parser_insert_delim(pemenc, pemsize, '\n', 64);

	return (SSL_OK);
}

static int	__crypt_encode(t_ostring *content, char **pemenc, size_t *pemsize)
{
	t_ostring	cipher;
	char		*crypt_pemenc;
	size_t		crypt_pemsize;
	int			ret;

	if (SSL_OK != __des_crypt(content, &cipher))
	{
		return (PEM_ERROR(UNSPECIFIED_ERROR));
	}
	if (SSL_OK == (ret = __encode(&cipher, pemenc, pemsize)))
	{
		__crypt_header(&crypt_pemenc, &crypt_pemsize);
		SSL_REALLOC(crypt_pemenc, crypt_pemsize, crypt_pemsize + *pemsize);
		__concat(crypt_pemenc, &crypt_pemsize, *pemenc, *pemsize);
		SSL_FREE(*pemenc);
		*pemenc = crypt_pemenc;
		*pemsize = crypt_pemsize;
	}
	SSL_FREE(cipher.content);

	return (ret);
}

int	pem_encode(
	t_ostring *content, t_pem **pem, const char *type, t_bool encrypt)
{
	char		*pemenc;
	size_t		pemsize;

	if (NULL == pem || NULL == content) {
		return (PEM_ERROR(INVALID_INPUT_ERROR));
	}
	*pem = NULL;

	if (encrypt) {
		if (SSL_OK != __crypt_encode(content, &pemenc, &pemsize)) {
			return (PEM_ERROR(UNSPECIFIED_ERROR));
		}
	} else if (SSL_OK != __encode(content, &pemenc, &pemsize)) {
		return (PEM_ERROR(UNSPECIFIED_ERROR));
	}
	pem_encap(pem, type, pemenc, pemsize);
	SSL_FREE(pemenc);

	return (SSL_OK);
}
